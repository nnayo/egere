#!/usr/bin/pytho
# -*- coding: latin-1 -*-

project_name = 'minut'


minut	= [
	'main.c',			\
	'minut.c',			\
	'servo.c',			\
	'mpu6050.c',		\
	'tk-off.c',			\
	'eeprom_frames.c',	\
]

import os

libs = ['scalp', 'nanoK']
libpath = [os.environ['TROLL_PROJECTS'] + '/scalp', os.environ['TROLL_PROJECTS'] + '/nanoK']

mcu_target      = 'atmega328p'
optimize        = '-Os -mcall-prologues -fshort-enums -std=c99 '
#optimize        = '-Os -mcall-prologues -fshort-enums '
includes	= [
				'.',
				os.environ['TROLL_PROJECTS'] + '/nanoK',
				os.environ['TROLL_PROJECTS'] + '/scalp',
				'/home/yog/TRoll/projects/simavr/simavr/sim/avr',
			]
cflags		= '-g -Wall ' + optimize + '-mmcu=' + mcu_target
ldflags		= '-g -Wall ' + optimize + '-mmcu=' + mcu_target + ' -Wl,-Map,' + project_name + '.map,--cref '
ldflags		+= '-Wl,--undefined=_mmcu,--section-start=.mmcu=0x8000'


builder_hex = Builder(
	action = Action(
		"avr-objcopy -O ihex -R .eeprom -R .mmcu $SOURCE $TARGET", cmdstr = "$HEXCOMSTR"), 
		suffix = ".hex", 
		src_suffix = ".elf"
)

env = Environment(
	CC = 'avr-gcc',		\
	AR = 'avr-ar',		\
	CFLAGS = cflags,	\
	CPPPATH = includes,	\
	LINKFLAGS = ldflags,	\
)

env.Append( BUILDERS = { 'Hex': builder_hex, } )
env.Hex(project_name, project_name)

Export('env')

SConscript([os.environ['TROLL_PROJECTS'] + '/scalp/SConscript', os.environ['TROLL_PROJECTS'] + '/nanoK/SConscript'], exports='env')

elf = env.Program(project_name + '.elf', minut, LIBS = libs, LIBPATH = libpath)
env.Default(elf)

# autogen eeprom_frame.c file
env.Depends('eeprom_frames.c', './gen_eeprom_frames.py eeprom_frames.c')

# generate a file with code and source
env.Alias('lis', project_name + '.elf', 'avr-objdump -h -SxD ' + project_name + '.elf > ' + project_name + '.lis')
env.AlwaysBuild('lis')


# give the size of the binary
env.Alias('size', project_name + '.elf', 'avr-size -t ' + project_name + '.elf')
env.AlwaysBuild('size')


# load binary in flash
load = env.Alias('load', project_name + '.hex', 'avrdude -V -c arduino -p ATMEGA328P -P /dev/ttyACM0 -b 57600 -U flash:w:' + project_name + '.hex')
env.AlwaysBuild(load)


# download the frames in eeprom
env.Depends('minut_eeprom_frames.hex', 'avr-objcopy --only-section .eeprom ' + project_name + '.hex' + 'minut_eeprom_frames.hex')
env.Alias('eeprom', 'minut_eeprom_frames.hex', 'avrdude -V -c arduino -p ATMEGA328P -D -P /dev/ttyACM0 -b 57600 -U eeprom:w:minut_eeprom_frames.hex:i')
env.AlwaysBuild('eeprom')


# connect to target with a terminal
env.Alias('term', '', 'avrdude -P usb -p ' + mcu_target + ' -c dragon_jtag -t')
env.AlwaysBuild('term')


# test with simavr
run = env.Alias('run', project_name + '.elf', '~/TRoll/projects/simavr/simavr/run_avr -t -v -m ' + mcu_target + ' -f 16000000  ' + project_name + '.elf -ee minut_eeprom_frames.hex')
env.AlwaysBuild(run)


# test with simavr & avr-gdb
# a dedicated version of simavr with MPU-6050 'simulation' is at:
# ~/TRoll/projects/simavr/examples/board_i2c_mpu6050
# launch it with:
# ./obj-x86_64-linux-gnu/i2ctest.elf ~/TRoll/projects/égère/soft/vol/minut/minut.elf g

sim = env.Alias('sim', project_name + '.elf', '~/TRoll/projects/simavr/simavr/run_avr -g -t -v -m ' + mcu_target + ' -f 16000000  ' + project_name + '.elf -ee minut_eeprom_frames.hex')
env.AlwaysBuild(sim)
sim2 = env.Alias('sim2', project_name + '.elf', '~/TRoll/projects/simavr/examples/board_i2c_mpu6050/obj-x86_64-linux-gnu/i2ctest.elf ~/TRoll/projects/égère/soft/vol/minut/minut.elf g')
env.AlwaysBuild(sim2)
gdb = env.Alias('gdb', project_name + '.elf', 'avr-gdb ' + project_name + '.elf -n -x gdbinit_avr')
env.AlwaysBuild(gdb)


# suppress reliquat files
env.Alias('clean', '', 'rm -f *~ *o */*.o *.a *.lis')
env.AlwaysBuild('clean')

